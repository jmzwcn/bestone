"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../common");
const plugin_1 = require("../plugin");
const common_2 = require("./common");
const cordova_1 = require("../cordova");
const fs_1 = require("../util/fs");
const path_1 = require("path");
const platform = 'android';
async function updateAndroid(config) {
    let plugins = await getPluginsTask(config);
    const capacitorPlugins = plugins.filter(p => plugin_1.getPluginType(p, platform) === 0 /* Core */);
    let cordovaPlugins = [];
    let needsPluginUpdate = true;
    while (needsPluginUpdate) {
        cordovaPlugins = plugins
            .filter(p => plugin_1.getPluginType(p, platform) === 1 /* Cordova */);
        needsPluginUpdate = await cordova_1.checkAndInstallDependencies(config, cordovaPlugins, platform);
        if (needsPluginUpdate) {
            plugins = await getPluginsTask(config);
        }
    }
    plugin_1.printPlugins(capacitorPlugins, 'android');
    removePluginsNativeFiles(config);
    if (cordovaPlugins.length > 0) {
        copyPluginsNativeFiles(config, cordovaPlugins);
    }
    await cordova_1.handleCordovaPluginsJS(cordovaPlugins, config, platform);
    await installGradlePlugins(config, capacitorPlugins, cordovaPlugins);
    await handleCordovaPluginsGradle(config, cordovaPlugins);
    await writeCordovaAndroidManifest(cordovaPlugins, config);
    const incompatibleCordovaPlugins = plugins
        .filter(p => plugin_1.getPluginType(p, platform) === 2 /* Incompatible */);
    plugin_1.printPlugins(incompatibleCordovaPlugins, platform, 'incompatible');
}
exports.updateAndroid = updateAndroid;
function getGradlePackageName(id) {
    return id.replace('@', '').replace('/', '-');
}
async function installGradlePlugins(config, capacitorPlugins, cordovaPlugins) {
    const settingsLines = `// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN
${capacitorPlugins.map(p => {
        return `
include ':${getGradlePackageName(p.id)}'
project(':${getGradlePackageName(p.id)}').projectDir = new File('../node_modules/${p.id}/android/${p.id}')
`;
    }).join('')}`;
    let applyArray = [];
    let frameworksArray = [];
    let prefsArray = [];
    cordovaPlugins.map(p => {
        const frameworks = plugin_1.getPlatformElement(p, platform, 'framework');
        frameworks.map((framework) => {
            if (framework.$.custom && framework.$.custom === 'true' && framework.$.type && framework.$.type === 'gradleReference') {
                applyArray.push(`apply from: "../../node_modules/${p.id}/${framework.$.src}"`);
            }
            else if (!framework.$.type && !framework.$.custom) {
                frameworksArray.push(`    implementation "${framework.$.src}"`);
            }
        });
        prefsArray = prefsArray.concat(plugin_1.getAllElements(p, platform, 'preference'));
    });
    let frameworkString = frameworksArray.join('\n');
    prefsArray.map((preference) => {
        frameworkString = frameworkString.replace(new RegExp(('$' + preference.$.name).replace('$', '\\$&'), 'g'), preference.$.default);
    });
    const dependencyLines = `// DO NOT EDIT THIS FILE! IT IS GENERATED EACH TIME "capacitor update" IS RUN

dependencies {
${capacitorPlugins.map(p => {
        return `    implementation project(':${getGradlePackageName(p.id)}')`;
    }).join('\n')}
${frameworkString}
}
${applyArray.join('\n')}

if (hasProperty('postBuildExtras')) {
  postBuildExtras()
}
`;
    await fs_1.writeFileAsync(path_1.join(config.app.rootDir, 'android/capacitor.settings.gradle'), settingsLines);
    await fs_1.writeFileAsync(path_1.join(config.app.rootDir, 'android/app/capacitor.build.gradle'), dependencyLines);
}
exports.installGradlePlugins = installGradlePlugins;
async function handleCordovaPluginsGradle(config, cordovaPlugins) {
    const pluginsFolder = path_1.resolve(config.app.rootDir, 'node_modules', '@capacitor/cli', 'assets', 'capacitor-android-plugins');
    const pluginsGradlePath = path_1.join(pluginsFolder, 'build.gradle');
    let frameworksArray = [];
    let prefsArray = [];
    let applyArray = [];
    cordovaPlugins.map(p => {
        const frameworks = plugin_1.getPlatformElement(p, platform, 'framework');
        frameworks.map((framework) => {
            if (!framework.$.type && !framework.$.custom) {
                frameworksArray.push(framework.$.src);
            }
            else if (framework.$.custom && framework.$.custom === 'true' && framework.$.type && framework.$.type === 'gradleReference') {
                applyArray.push(`apply from: "../../../../${p.id}/${framework.$.src}"`);
            }
        });
        prefsArray = prefsArray.concat(plugin_1.getAllElements(p, platform, 'preference'));
    });
    let frameworkString = frameworksArray.map(f => {
        return `    implementation "${f}"`;
    }).join('\n');
    prefsArray.map((preference) => {
        frameworkString = frameworkString.replace(new RegExp(('$' + preference.$.name).replace('$', '\\$&'), 'g'), preference.$.default);
    });
    let applyString = applyArray.join('\n');
    let buildGradle = await fs_1.readFileAsync(pluginsGradlePath, 'utf8');
    buildGradle = buildGradle.replace(/(SUB-PROJECT DEPENDENCIES START)[\s\S]*(\/\/ SUB-PROJECT DEPENDENCIES END)/, '$1\n' + frameworkString.concat('\n') + '    $2');
    buildGradle = buildGradle.replace(/(PLUGIN GRADLE EXTENSIONS START)[\s\S]*(\/\/ PLUGIN GRADLE EXTENSIONS END)/, '$1\n' + applyString.concat('\n') + '$2');
    await fs_1.writeFileAsync(pluginsGradlePath, buildGradle);
}
exports.handleCordovaPluginsGradle = handleCordovaPluginsGradle;
function copyPluginsNativeFiles(config, cordovaPlugins) {
    const pluginsRoot = path_1.resolve(config.app.rootDir, 'node_modules', '@capacitor/cli', 'assets', 'capacitor-android-plugins');
    const pluginsPath = path_1.join(pluginsRoot, 'src', 'main');
    cordovaPlugins.map(p => {
        const androidPlatform = plugin_1.getPluginPlatform(p, platform);
        if (androidPlatform) {
            const sourceFiles = androidPlatform['source-file'];
            if (sourceFiles) {
                sourceFiles.map((sourceFile) => {
                    const fileName = sourceFile.$.src.split('/').pop();
                    const target = sourceFile.$['target-dir'].replace('app/src/main/', '').replace('src/', 'java/');
                    fs_1.copySync(plugin_1.getFilePath(config, p, sourceFile.$.src), path_1.join(pluginsPath, target, fileName));
                });
            }
            const resourceFiles = androidPlatform['resource-file'];
            if (resourceFiles) {
                resourceFiles.map((resourceFile) => {
                    const target = resourceFile.$['target'];
                    if (resourceFile.$.src.split('.').pop() === 'aar') {
                        fs_1.copySync(plugin_1.getFilePath(config, p, resourceFile.$.src), path_1.join(pluginsPath, 'libs', target.split('/').pop()));
                    }
                    else if (target !== ".") {
                        fs_1.copySync(plugin_1.getFilePath(config, p, resourceFile.$.src), path_1.join(pluginsPath, target));
                    }
                });
            }
            const libFiles = plugin_1.getPlatformElement(p, platform, 'lib-file');
            libFiles.map((libFile) => {
                fs_1.copySync(plugin_1.getFilePath(config, p, libFile.$.src), path_1.join(pluginsPath, 'libs', libFile.$.src.split('/').pop()));
            });
        }
    });
}
function removePluginsNativeFiles(config) {
    const pluginsRoot = path_1.resolve(config.app.rootDir, 'node_modules', '@capacitor/cli', 'assets', 'capacitor-android-plugins');
    const pluginsPath = path_1.join(pluginsRoot, 'src', 'main');
    fs_1.removeSync(path_1.join(pluginsPath, 'java'));
    fs_1.removeSync(path_1.join(pluginsPath, 'res'));
    fs_1.removeSync(path_1.join(pluginsPath, 'libs'));
}
async function getPluginsTask(config) {
    return await common_1.runTask('Updating Android plugins', async () => {
        const allPlugins = await plugin_1.getPlugins(config);
        const androidPlugins = await common_2.getAndroidPlugins(config, allPlugins);
        return androidPlugins;
    });
}
async function writeCordovaAndroidManifest(cordovaPlugins, config) {
    const pluginsFolder = path_1.resolve(config.app.rootDir, 'node_modules', '@capacitor/cli', 'assets', 'capacitor-android-plugins');
    const manifestPath = path_1.join(pluginsFolder, 'src', 'main', 'AndroidManifest.xml');
    let rootXMLEntries = [];
    let applicationXMLEntries = [];
    cordovaPlugins.map(async (p) => {
        const editConfig = plugin_1.getPlatformElement(p, platform, 'edit-config');
        const configFile = plugin_1.getPlatformElement(p, platform, 'config-file');
        editConfig.concat(configFile).map(async (configElement) => {
            if (configElement.$.target.includes('AndroidManifest.xml')) {
                const keys = Object.keys(configElement).filter(k => k !== '$');
                keys.map(k => {
                    configElement[k].map((e) => {
                        const xmlElement = common_1.buildXmlElement(e, k);
                        const pathParts = getPathParts(configElement.$.parent);
                        if (pathParts.length > 1) {
                            if (pathParts.pop() === 'application') {
                                if (!applicationXMLEntries.includes(xmlElement) && !contains(applicationXMLEntries, xmlElement, k)) {
                                    applicationXMLEntries.push(xmlElement);
                                }
                            }
                            else {
                                common_1.logInfo(`plugin ${p.id} requires to add \n  ${xmlElement} to your Info.plist to work`);
                            }
                        }
                        else {
                            if (!rootXMLEntries.includes(xmlElement) && !contains(rootXMLEntries, xmlElement, k)) {
                                rootXMLEntries.push(xmlElement);
                            }
                        }
                    });
                });
            }
        });
    });
    let content = `<?xml version='1.0' encoding='utf-8'?>
<manifest package="capacitor.android.plugins"
xmlns:android="http://schemas.android.com/apk/res/android"
xmlns:amazon="http://schemas.amazon.com/apk/res/android">
<application>
${applicationXMLEntries.join('\n')}
</application>
${rootXMLEntries.join('\n')}
</manifest>`;
    content = content.replace(new RegExp(('$PACKAGE_NAME').replace('$', '\\$&'), 'g'), config.app.appId);
    await fs_1.writeFileAsync(manifestPath, content);
}
function getPathParts(path) {
    const rootPath = 'manifest';
    path = path.replace('/*', rootPath);
    let parts = path.split('/').filter(part => part !== '');
    if (parts.length > 1 || parts.includes(rootPath)) {
        return parts;
    }
    return [rootPath, path];
}
function contains(a, obj, k) {
    const element = common_1.parseXML(obj);
    for (var i = 0; i < a.length; i++) {
        const current = common_1.parseXML(a[i]);
        if (element && current && current[k] && element[k] && current[k].$ && element[k].$ && element[k].$["android:name"] === current[k].$["android:name"]) {
            return true;
        }
    }
    return false;
}
